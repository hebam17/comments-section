{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { getDefaultLocale, setDefaultLocale, getLocaleData, addLocaleData } from './LocaleDataStore';\nimport resolveLocale from './resolveLocale';\nimport PluralRules from './PluralRules'; // Importing `PluralRule` polyfill from a separate package\n// results in a bundle that is larger by 1kB for some reason.\n// import PluralRules from 'intl-plural-rules-polyfill/cardinal'\n// Valid time units.\n\nexport var UNITS = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"]; // Valid values for the `numeric` option.\n\nvar NUMERIC_VALUES = [\"auto\", \"always\"]; // Valid values for the `style` option.\n\nvar STYLE_VALUES = [\"long\", \"short\", \"narrow\"]; // Valid values for the `localeMatcher` option.\n\nvar LOCALE_MATCHER_VALUES = [\"lookup\", \"best fit\"];\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\n\nvar RelativeTimeFormat = /*#__PURE__*/function () {\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"lookup\"] - One of: \"lookup\", \"best fit\". Currently only \"lookup\" is supported.\r\n   * @param {boolean} [options.styleFallback] - If \"style\" is missing from locale data then fall back to an existing one (for example, \"long\"). Is used in `javascript-time-ago`.\r\n   */\n  function RelativeTimeFormat() {\n    var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, RelativeTimeFormat);\n\n    _defineProperty(this, \"numeric\", \"always\");\n\n    _defineProperty(this, \"style\", \"long\");\n\n    _defineProperty(this, \"localeMatcher\", \"lookup\");\n\n    var numeric = options.numeric,\n        style = options.style,\n        styleFallback = options.styleFallback,\n        localeMatcher = options.localeMatcher; // Set `numeric` option.\n\n    if (numeric !== undefined) {\n      if (NUMERIC_VALUES.indexOf(numeric) < 0) {\n        throw new RangeError(\"Invalid \\\"numeric\\\" option: \".concat(numeric));\n      }\n\n      this.numeric = numeric;\n    } // Set `style` option.\n\n\n    if (style !== undefined) {\n      if (STYLE_VALUES.indexOf(style) < 0 && !styleFallback) {\n        throw new RangeError(\"Invalid \\\"style\\\" option: \".concat(style));\n      }\n\n      this.style = style;\n    } // Set `localeMatcher` option.\n\n\n    if (localeMatcher !== undefined) {\n      if (LOCALE_MATCHER_VALUES.indexOf(localeMatcher) < 0) {\n        throw new RangeError(\"Invalid \\\"localeMatcher\\\" option: \".concat(localeMatcher));\n      }\n\n      this.localeMatcher = localeMatcher;\n    } // Set `locale`.\n    // Convert `locales` to an array.\n\n\n    if (typeof locales === 'string') {\n      locales = [locales];\n    } // Add default locale.\n\n\n    locales.push(getDefaultLocale()); // Choose the most appropriate locale.\n\n    this.locale = RelativeTimeFormat.supportedLocalesOf(locales, {\n      localeMatcher: this.localeMatcher\n    })[0];\n\n    if (!this.locale) {\n      throw new Error(\"No supported locale was found\");\n    } // Construct an `Intl.PluralRules` instance (polyfill).\n\n\n    if (PluralRules.supportedLocalesOf(this.locale).length > 0) {\n      this.pluralRules = new PluralRules(this.locale);\n    } else {\n      console.warn(\"\\\"\".concat(this.locale, \"\\\" locale is not supported\"));\n    } // Use `Intl.NumberFormat` for formatting numbers (when available).\n\n\n    if (typeof Intl !== 'undefined' && Intl.NumberFormat) {\n      this.numberFormat = new Intl.NumberFormat(this.locale);\n      this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem;\n    } else {\n      this.numberingSystem = 'latn';\n    }\n\n    this.locale = resolveLocale(this.locale, {\n      localeMatcher: this.localeMatcher\n    }); // Fall back to another style if `style` is not supported for the `locale`.\n\n    if (styleFallback) {\n      var styles = Object.keys(getLocaleData(this.locale));\n\n      var _arr = [this.style].concat(STYLE_VALUES, [styles[0]]);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var _style = _arr[_i];\n\n        if (styles.indexOf(_style) >= 0) {\n          this.style = _style;\n          break;\n        }\n      }\n    }\n  }\n  /**\r\n   * Formats time `number` in `units` (either in past or in future).\r\n   * @param {number} number - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\n\n\n  _createClass(RelativeTimeFormat, [{\n    key: \"format\",\n    value: function format() {\n      var _parseFormatArgs = parseFormatArgs(arguments),\n          _parseFormatArgs2 = _slicedToArray(_parseFormatArgs, 2),\n          number = _parseFormatArgs2[0],\n          unit = _parseFormatArgs2[1];\n\n      return this.getRule(number, unit).replace('{0}', this.formatNumber(Math.abs(number)));\n    }\n    /**\r\n     * Formats time `number` in `units` (either in past or in future).\r\n     * @param {number} number - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {Object[]} The parts (`{ type, value, unit? }`).\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Version 1 (deprecated).\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"day\", value: \"100\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     * //\r\n     * // Version 2.\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     */\n\n  }, {\n    key: \"formatToParts\",\n    value: function formatToParts() {\n      var _parseFormatArgs3 = parseFormatArgs(arguments),\n          _parseFormatArgs4 = _slicedToArray(_parseFormatArgs3, 2),\n          number = _parseFormatArgs4[0],\n          unit = _parseFormatArgs4[1];\n\n      var rule = this.getRule(number, unit);\n      var valueIndex = rule.indexOf(\"{0}\"); // \"yesterday\"/\"today\"/\"tomorrow\".\n\n      if (valueIndex < 0) {\n        return [{\n          type: \"literal\",\n          value: rule\n        }];\n      }\n\n      var parts = [];\n\n      if (valueIndex > 0) {\n        parts.push({\n          type: \"literal\",\n          value: rule.slice(0, valueIndex)\n        });\n      }\n\n      parts = parts.concat(this.formatNumberToParts(Math.abs(number)).map(function (part) {\n        return _objectSpread({}, part, {\n          unit: unit\n        });\n      }));\n\n      if (valueIndex + \"{0}\".length < rule.length - 1) {\n        parts.push({\n          type: \"literal\",\n          value: rule.slice(valueIndex + \"{0}\".length)\n        });\n      }\n\n      return parts;\n    }\n    /**\r\n     * Returns formatting rule for `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {string}\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Returns \"{0} days ago\"\r\n     * getRule(-2, \"day\")\r\n     */\n\n  }, {\n    key: \"getRule\",\n    value: function getRule(value, unit) {\n      // Get locale-specific time interval formatting rules\n      // of a given `style` for the given value of measurement `unit`.\n      //\n      // E.g.:\n      //\n      // ```json\n      // {\n      //  \"past\": {\n      //    \"one\": \"a second ago\",\n      //    \"other\": \"{0} seconds ago\"\n      //  },\n      //  \"future\": {\n      //    \"one\": \"in a second\",\n      //    \"other\": \"in {0} seconds\"\n      //  }\n      // }\n      // ```\n      //\n      var unitMessages = getLocaleData(this.locale)[this.style][unit]; // Bundle size optimization technique for styles like\n      // \"tiny\" in `javascript-time-ago`: \"1m\", \"2h\", \"3d\"...\n\n      if (typeof unitMessages === 'string') {\n        return unitMessages;\n      } // Special case for \"yesterday\"/\"today\"/\"tomorrow\".\n\n\n      if (this.numeric === \"auto\") {\n        // \"yesterday\", \"the day before yesterday\", etc.\n        if (value === -2 || value === -1) {\n          var message = unitMessages[\"previous\".concat(value === -1 ? '' : '-' + Math.abs(value))];\n\n          if (message) {\n            return message;\n          }\n        } // \"tomorrow\", \"the day after tomorrow\", etc.\n        else if (value === 1 || value === 2) {\n          var _message = unitMessages[\"next\".concat(value === 1 ? '' : '-' + Math.abs(value))];\n\n          if (_message) {\n            return _message;\n          }\n        } // \"today\"\n        else if (value === 0) {\n          if (unitMessages.current) {\n            return unitMessages.current;\n          }\n        }\n      } // Choose either \"past\" or \"future\" based on time `value` sign.\n      // If there's only \"other\" then it's being collapsed.\n      // (the resulting bundle size optimization technique)\n\n\n      var pluralizedMessages = unitMessages[isNegative(value) ? \"past\" : \"future\"]; // Bundle size optimization technique for styles like \"narrow\"\n      // having messages like \"in {0} d.\" or \"{0} d. ago\".\n\n      if (typeof pluralizedMessages === \"string\") {\n        return pluralizedMessages;\n      } // Quantify `value`.\n      // There seems to be no such locale in CLDR\n      // for which \"plural rules\" function is missing.\n\n\n      var quantifier = this.pluralRules && this.pluralRules.select(Math.abs(value)) || 'other'; // \"other\" rule is supposed to be always present.\n      // If only \"other\" rule is present then \"rules\" is not an object and is a string.\n\n      return pluralizedMessages[quantifier] || pluralizedMessages.other;\n    }\n    /**\r\n     * Formats a number into a string.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {string}\r\n     */\n\n  }, {\n    key: \"formatNumber\",\n    value: function formatNumber(number) {\n      return this.numberFormat ? this.numberFormat.format(number) : String(number);\n    }\n    /**\r\n     * Formats a number into a list of parts.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {object[]}\r\n     */\n\n  }, {\n    key: \"formatNumberToParts\",\n    value: function formatNumberToParts(number) {\n      // `Intl.NumberFormat.formatToParts()` is not present, for example,\n      // in Node.js 8.x while `Intl.NumberFormat` itself is present.\n      return this.numberFormat && this.numberFormat.formatToParts ? this.numberFormat.formatToParts(number) : [{\n        type: \"integer\",\n        value: this.formatNumber(number)\n      }];\n    }\n    /**\r\n     * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"resolvedOptions\",\n    value: function resolvedOptions() {\n      return {\n        locale: this.locale,\n        style: this.style,\n        numeric: this.numeric,\n        numberingSystem: this.numberingSystem\n      };\n    }\n  }]);\n\n  return RelativeTimeFormat;\n}();\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'es-PY']\r\n * var options = { localeMatcher: 'lookup' }\r\n * // Returns [\"id\", \"es-PY\"]\r\n * Intl.RelativeTimeFormat.supportedLocalesOf(locales, options)\r\n */\n\n\nexport { RelativeTimeFormat as default };\n\nRelativeTimeFormat.supportedLocalesOf = function (locales) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Convert `locales` to an array.\n\n  if (typeof locales === 'string') {\n    locales = [locales];\n  } else if (!Array.isArray(locales)) {\n    throw new TypeError('Invalid \"locales\" argument');\n  }\n\n  return locales.filter(function (locale) {\n    return resolveLocale(locale, options);\n  });\n};\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\n\n\nRelativeTimeFormat.addLocale = addLocaleData;\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\n\nRelativeTimeFormat.setDefaultLocale = setDefaultLocale;\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\n\nRelativeTimeFormat.getDefaultLocale = getDefaultLocale;\n/**\r\n * Export `Intl.PluralRules` just in case it's used somewhere else.\r\n */\n\nRelativeTimeFormat.PluralRules = PluralRules; // The specification allows units to be in plural form.\n// Convert plural to singular.\n// Example: \"seconds\" -> \"second\".\n\nvar UNIT_ERROR = 'Invalid \"unit\" argument';\n\nfunction parseUnit(unit) {\n  if (_typeof(unit) === 'symbol') {\n    throw new TypeError(UNIT_ERROR);\n  }\n\n  if (typeof unit !== 'string') {\n    throw new RangeError(\"\".concat(UNIT_ERROR, \": \").concat(unit));\n  }\n\n  if (unit[unit.length - 1] === 's') {\n    unit = unit.slice(0, unit.length - 1);\n  }\n\n  if (UNITS.indexOf(unit) < 0) {\n    throw new RangeError(\"\".concat(UNIT_ERROR, \": \").concat(unit));\n  }\n\n  return unit;\n} // Converts `value` to a `Number`.\n// The specification allows value to be a non-number.\n// For example, \"-0\" is supposed to be treated as `-0`.\n// Also checks if `value` is a finite number.\n\n\nvar NUMBER_ERROR = 'Invalid \"number\" argument';\n\nfunction parseNumber(value) {\n  value = Number(value);\n\n  if (Number.isFinite) {\n    if (!Number.isFinite(value)) {\n      throw new RangeError(\"\".concat(NUMBER_ERROR, \": \").concat(value));\n    }\n  }\n\n  return value;\n}\n/**\r\n * Tells `0` from `-0`.\r\n * https://stackoverflow.com/questions/7223359/are-0-and-0-the-same\r\n * @param  {number} number\r\n * @return {Boolean}\r\n * @example\r\n * isNegativeZero(0); // false\r\n * isNegativeZero(-0); // true\r\n */\n\n\nfunction isNegativeZero(number) {\n  return 1 / number === -Infinity;\n}\n\nfunction isNegative(number) {\n  return number < 0 || number === 0 && isNegativeZero(number);\n}\n\nfunction parseFormatArgs(args) {\n  if (args.length < 2) {\n    throw new TypeError(\"\\\"unit\\\" argument is required\");\n  }\n\n  return [parseNumber(args[0]), parseUnit(args[1])];\n}","map":{"version":3,"mappings":"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","names":["getDefaultLocale","setDefaultLocale","getLocaleData","addLocaleData","resolveLocale","PluralRules","UNITS","NUMERIC_VALUES","STYLE_VALUES","LOCALE_MATCHER_VALUES","RelativeTimeFormat","locales","options","_classCallCheck","_defineProperty","numeric","style","styleFallback","localeMatcher","undefined","indexOf","RangeError","push","locale","supportedLocalesOf","Error","length","pluralRules","console","warn","Intl","NumberFormat","numberFormat","numberingSystem","resolvedOptions","styles","Object","keys","parseFormatArgs","arguments","number","unit","getRule","replace","formatNumber","Math","abs","rule","valueIndex","type","value","parts","slice","concat","formatNumberToParts","map","part","unitMessages","message","current","pluralizedMessages","isNegative","quantifier","select","other","format","String","formatToParts","Array","isArray","TypeError","filter","addLocale","UNIT_ERROR","parseUnit","_typeof","NUMBER_ERROR","parseNumber","Number","isFinite","isNegativeZero","Infinity","args"],"sources":["E:\\courses\\my_personal_file\\challenges\\comments-section\\client\\node_modules\\relative-time-format\\source\\RelativeTimeFormat.js"],"sourcesContent":["import {\r\n  getDefaultLocale,\r\n  setDefaultLocale,\r\n  getLocaleData,\r\n  addLocaleData\r\n} from './LocaleDataStore'\r\n\r\nimport resolveLocale from './resolveLocale'\r\nimport PluralRules from './PluralRules'\r\n// Importing `PluralRule` polyfill from a separate package\r\n// results in a bundle that is larger by 1kB for some reason.\r\n// import PluralRules from 'intl-plural-rules-polyfill/cardinal'\r\n\r\n// Valid time units.\r\nexport const UNITS = [\r\n  \"second\",\r\n  \"minute\",\r\n  \"hour\",\r\n  \"day\",\r\n  \"week\",\r\n  \"month\",\r\n  \"quarter\",\r\n  \"year\"\r\n]\r\n\r\n// Valid values for the `numeric` option.\r\nconst NUMERIC_VALUES = [\r\n  \"auto\",\r\n  \"always\"\r\n]\r\n\r\n// Valid values for the `style` option.\r\nconst STYLE_VALUES = [\r\n  \"long\",\r\n  \"short\",\r\n  \"narrow\"\r\n]\r\n\r\n// Valid values for the `localeMatcher` option.\r\nconst LOCALE_MATCHER_VALUES = [\r\n  \"lookup\",\r\n  \"best fit\"\r\n]\r\n\r\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\r\nexport default class RelativeTimeFormat {\r\n  numeric = \"always\"\r\n  style = \"long\"\r\n  localeMatcher = \"lookup\"\r\n\r\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"lookup\"] - One of: \"lookup\", \"best fit\". Currently only \"lookup\" is supported.\r\n   * @param {boolean} [options.styleFallback] - If \"style\" is missing from locale data then fall back to an existing one (for example, \"long\"). Is used in `javascript-time-ago`.\r\n   */\r\n  constructor(locales = [], options = {}) {\r\n    const {\r\n      numeric,\r\n      style,\r\n      styleFallback,\r\n      localeMatcher\r\n    } = options\r\n\r\n    // Set `numeric` option.\r\n    if (numeric !== undefined) {\r\n      if (NUMERIC_VALUES.indexOf(numeric) < 0) {\r\n        throw new RangeError(`Invalid \"numeric\" option: ${numeric}`)\r\n      }\r\n      this.numeric = numeric\r\n    }\r\n\r\n    // Set `style` option.\r\n    if (style !== undefined) {\r\n      if (STYLE_VALUES.indexOf(style) < 0 && !styleFallback) {\r\n        throw new RangeError(`Invalid \"style\" option: ${style}`)\r\n      }\r\n      this.style = style\r\n    }\r\n\r\n    // Set `localeMatcher` option.\r\n    if (localeMatcher !== undefined) {\r\n      if (LOCALE_MATCHER_VALUES.indexOf(localeMatcher) < 0) {\r\n        throw new RangeError(`Invalid \"localeMatcher\" option: ${localeMatcher}`)\r\n      }\r\n      this.localeMatcher = localeMatcher\r\n    }\r\n\r\n    // Set `locale`.\r\n    // Convert `locales` to an array.\r\n    if (typeof locales === 'string') {\r\n      locales = [locales]\r\n    }\r\n    // Add default locale.\r\n    locales.push(getDefaultLocale())\r\n    // Choose the most appropriate locale.\r\n    this.locale = RelativeTimeFormat.supportedLocalesOf(locales, {\r\n      localeMatcher: this.localeMatcher\r\n    })[0]\r\n    if (!this.locale) {\r\n      throw new Error(\"No supported locale was found\")\r\n    }\r\n\r\n    // Construct an `Intl.PluralRules` instance (polyfill).\r\n    if (PluralRules.supportedLocalesOf(this.locale).length > 0) {\r\n      this.pluralRules = new PluralRules(this.locale)\r\n    } else {\r\n      console.warn(`\"${this.locale}\" locale is not supported`)\r\n    }\r\n\r\n    // Use `Intl.NumberFormat` for formatting numbers (when available).\r\n    if (typeof Intl !== 'undefined' && Intl.NumberFormat) {\r\n      this.numberFormat = new Intl.NumberFormat(this.locale)\r\n      this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem\r\n    } else {\r\n      this.numberingSystem = 'latn'\r\n    }\r\n\r\n    this.locale = resolveLocale(this.locale, {\r\n      localeMatcher: this.localeMatcher\r\n    })\r\n\r\n    // Fall back to another style if `style` is not supported for the `locale`.\r\n    if (styleFallback) {\r\n      const styles = Object.keys(getLocaleData(this.locale))\r\n      for (const style of [this.style, ...STYLE_VALUES, styles[0]]) {\r\n        if (styles.indexOf(style) >= 0) {\r\n          this.style = style\r\n          break\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Formats time `number` in `units` (either in past or in future).\r\n   * @param {number} number - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\r\n  format() {\r\n    const [number, unit] = parseFormatArgs(arguments)\r\n    return this.getRule(number, unit).replace('{0}', this.formatNumber(Math.abs(number)))\r\n  }\r\n\r\n  /**\r\n   * Formats time `number` in `units` (either in past or in future).\r\n   * @param {number} number - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {Object[]} The parts (`{ type, value, unit? }`).\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Version 1 (deprecated).\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"day\", value: \"100\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   * //\r\n   * // Version 2.\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   */\r\n  formatToParts() {\r\n    const [number, unit] = parseFormatArgs(arguments)\r\n    const rule = this.getRule(number, unit)\r\n    const valueIndex = rule.indexOf(\"{0}\")\r\n    // \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (valueIndex < 0) {\r\n      return [{\r\n        type: \"literal\",\r\n        value: rule\r\n      }]\r\n    }\r\n    let parts = []\r\n    if (valueIndex > 0) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(0, valueIndex)\r\n      })\r\n    }\r\n    parts = parts.concat(\r\n      this.formatNumberToParts(Math.abs(number))\r\n        .map(part => ({ ...part, unit }))\r\n    )\r\n    if (valueIndex + \"{0}\".length < rule.length - 1) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(valueIndex + \"{0}\".length)\r\n      })\r\n    }\r\n    return parts\r\n  }\r\n\r\n  /**\r\n   * Returns formatting rule for `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"{0} days ago\"\r\n   * getRule(-2, \"day\")\r\n   */\r\n  getRule(value, unit) {\r\n    // Get locale-specific time interval formatting rules\r\n    // of a given `style` for the given value of measurement `unit`.\r\n    //\r\n    // E.g.:\r\n    //\r\n    // ```json\r\n    // {\r\n    //  \"past\": {\r\n    //    \"one\": \"a second ago\",\r\n    //    \"other\": \"{0} seconds ago\"\r\n    //  },\r\n    //  \"future\": {\r\n    //    \"one\": \"in a second\",\r\n    //    \"other\": \"in {0} seconds\"\r\n    //  }\r\n    // }\r\n    // ```\r\n    //\r\n    const unitMessages = getLocaleData(this.locale)[this.style][unit]\r\n    // Bundle size optimization technique for styles like\r\n    // \"tiny\" in `javascript-time-ago`: \"1m\", \"2h\", \"3d\"...\r\n    if (typeof unitMessages === 'string') {\r\n      return unitMessages\r\n    }\r\n    // Special case for \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (this.numeric === \"auto\") {\r\n      // \"yesterday\", \"the day before yesterday\", etc.\r\n      if (value === -2 || value === -1) {\r\n        const message = unitMessages[`previous${value === -1 ? '' : '-' + Math.abs(value)}`]\r\n        if (message) {\r\n          return message\r\n        }\r\n      }\r\n      // \"tomorrow\", \"the day after tomorrow\", etc.\r\n      else if (value === 1 || value === 2) {\r\n        const message = unitMessages[`next${value === 1 ? '' : '-' + Math.abs(value)}`]\r\n        if (message) {\r\n          return message\r\n        }\r\n      }\r\n      // \"today\"\r\n      else if (value === 0) {\r\n        if (unitMessages.current) {\r\n          return unitMessages.current\r\n        }\r\n      }\r\n    }\r\n    // Choose either \"past\" or \"future\" based on time `value` sign.\r\n    // If there's only \"other\" then it's being collapsed.\r\n    // (the resulting bundle size optimization technique)\r\n    const pluralizedMessages = unitMessages[isNegative(value) ? \"past\" : \"future\"]\r\n    // Bundle size optimization technique for styles like \"narrow\"\r\n    // having messages like \"in {0} d.\" or \"{0} d. ago\".\r\n    if (typeof pluralizedMessages === \"string\") {\r\n      return pluralizedMessages\r\n    }\r\n    // Quantify `value`.\r\n    // There seems to be no such locale in CLDR\r\n    // for which \"plural rules\" function is missing.\r\n    const quantifier = this.pluralRules && this.pluralRules.select(Math.abs(value)) || 'other'\r\n    // \"other\" rule is supposed to be always present.\r\n    // If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n    return pluralizedMessages[quantifier] || pluralizedMessages.other\r\n  }\r\n\r\n  /**\r\n   * Formats a number into a string.\r\n   * Uses `Intl.NumberFormat` when available.\r\n   * @param  {number} number\r\n   * @return {string}\r\n   */\r\n  formatNumber(number) {\r\n    return this.numberFormat ? this.numberFormat.format(number) : String(number)\r\n  }\r\n\r\n  /**\r\n   * Formats a number into a list of parts.\r\n   * Uses `Intl.NumberFormat` when available.\r\n   * @param  {number} number\r\n   * @return {object[]}\r\n   */\r\n  formatNumberToParts(number) {\r\n    // `Intl.NumberFormat.formatToParts()` is not present, for example,\r\n    // in Node.js 8.x while `Intl.NumberFormat` itself is present.\r\n    return this.numberFormat && this.numberFormat.formatToParts ?\r\n      this.numberFormat.formatToParts(number) :\r\n      [{\r\n        type: \"integer\",\r\n        value: this.formatNumber(number)\r\n      }]\r\n  }\r\n\r\n  /**\r\n   * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n   * @return {Object}\r\n   */\r\n  resolvedOptions() {\r\n    return {\r\n      locale: this.locale,\r\n      style: this.style,\r\n      numeric: this.numeric,\r\n      numberingSystem: this.numberingSystem\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'es-PY']\r\n * var options = { localeMatcher: 'lookup' }\r\n * // Returns [\"id\", \"es-PY\"]\r\n * Intl.RelativeTimeFormat.supportedLocalesOf(locales, options)\r\n */\r\nRelativeTimeFormat.supportedLocalesOf = function(locales, options = {}) {\r\n  // Convert `locales` to an array.\r\n  if (typeof locales === 'string') {\r\n    locales = [locales]\r\n  } else if (!Array.isArray(locales)) {\r\n    throw new TypeError('Invalid \"locales\" argument')\r\n  }\r\n  return locales.filter(locale => resolveLocale(locale, options))\r\n}\r\n\r\n/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */\r\nRelativeTimeFormat.addLocale = addLocaleData\r\n\r\n/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */\r\nRelativeTimeFormat.setDefaultLocale = setDefaultLocale\r\n\r\n/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */\r\nRelativeTimeFormat.getDefaultLocale = getDefaultLocale\r\n\r\n/**\r\n * Export `Intl.PluralRules` just in case it's used somewhere else.\r\n */\r\nRelativeTimeFormat.PluralRules = PluralRules\r\n\r\n// The specification allows units to be in plural form.\r\n// Convert plural to singular.\r\n// Example: \"seconds\" -> \"second\".\r\nconst UNIT_ERROR = 'Invalid \"unit\" argument'\r\nfunction parseUnit(unit) {\r\n  if (typeof unit === 'symbol') {\r\n    throw new TypeError(UNIT_ERROR)\r\n  }\r\n  if (typeof unit !== 'string') {\r\n    throw new RangeError(`${UNIT_ERROR}: ${unit}`)\r\n  }\r\n  if (unit[unit.length - 1] === 's') {\r\n    unit = unit.slice(0, unit.length - 1)\r\n  }\r\n  if (UNITS.indexOf(unit) < 0) {\r\n    throw new RangeError(`${UNIT_ERROR}: ${unit}`)\r\n  }\r\n  return unit\r\n}\r\n\r\n// Converts `value` to a `Number`.\r\n// The specification allows value to be a non-number.\r\n// For example, \"-0\" is supposed to be treated as `-0`.\r\n// Also checks if `value` is a finite number.\r\nconst NUMBER_ERROR = 'Invalid \"number\" argument'\r\nfunction parseNumber(value) {\r\n  value = Number(value)\r\n  if (Number.isFinite) {\r\n    if (!Number.isFinite(value)) {\r\n      throw new RangeError(`${NUMBER_ERROR}: ${value}`)\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Tells `0` from `-0`.\r\n * https://stackoverflow.com/questions/7223359/are-0-and-0-the-same\r\n * @param  {number} number\r\n * @return {Boolean}\r\n * @example\r\n * isNegativeZero(0); // false\r\n * isNegativeZero(-0); // true\r\n */\r\nfunction isNegativeZero(number) {\r\n  return 1 / number === -Infinity\r\n}\r\n\r\nfunction isNegative(number) {\r\n  return number < 0 || number === 0 && isNegativeZero(number)\r\n}\r\n\r\nfunction parseFormatArgs(args) {\r\n  if (args.length < 2) {\r\n    throw new TypeError(`\"unit\" argument is required`)\r\n  }\r\n  return [\r\n    parseNumber(args[0]),\r\n    parseUnit(args[1])\r\n  ]\r\n}"]},"metadata":{},"sourceType":"module"}