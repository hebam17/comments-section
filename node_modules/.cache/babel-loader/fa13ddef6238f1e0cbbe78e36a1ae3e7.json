{"ast":null,"code":"import { resolveLocale as resolveLocaleForData } from './LocaleDataStore';\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * @param  {string} locale\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocale(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocale(\"xx-Latn\")\r\n */\n\nexport default function resolveLocale(locale) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var localeMatcher = options.localeMatcher || 'lookup';\n\n  switch (localeMatcher) {\n    case 'lookup':\n      return resolveLocaleLookup(locale);\n    // \"best fit\" locale matching is not supported.\n    // https://github.com/catamphetamine/relative-time-format/issues/2\n\n    case 'best fit':\n      // return resolveLocaleBestFit(locale)\n      return resolveLocaleLookup(locale);\n\n    default:\n      throw new RangeError(\"Invalid \\\"localeMatcher\\\" option: \".concat(localeMatcher));\n  }\n}\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * Starts from the most specific locale and gradually\r\n * falls back to less specific ones.\r\n * This is a basic implementation of the \"lookup\" algorithm.\r\n * https://tools.ietf.org/html/rfc4647#section-3.4\r\n * @param  {string} locale\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocaleLookup(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocaleLookup(\"xx-Latn\")\r\n */\n\nexport function resolveLocaleLookup(locale) {\n  var resolvedLocale = resolveLocaleForData(locale);\n\n  if (resolvedLocale) {\n    return resolvedLocale;\n  } // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\n\n\n  var parts = locale.split('-');\n\n  while (locale.length > 1) {\n    parts.pop();\n    locale = parts.join('-');\n\n    var _resolvedLocale = resolveLocaleForData(locale);\n\n    if (_resolvedLocale) {\n      return _resolvedLocale;\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA,SACEA,aAAa,IAAIC,oBADnB,QAEO,mBAFP;AAIA;;;;;;;;;;;;;AAYA,eAAe,SAASD,aAAT,CAAuBE,MAAvB,EAA6C;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC1D,MAAMC,aAAa,GAAGD,OAAO,CAACC,aAARD,IAAyB,QAA/C;;AACA,UAAQC,aAAR;AACE,SAAK,QAAL;AACE,aAAOC,mBAAmB,CAACH,MAAD,CAA1B;AACF;AACA;;AACA,SAAK,UAAL;AACE;AACA,aAAOG,mBAAmB,CAACH,MAAD,CAA1B;;AACF;AACE,YAAM,IAAII,UAAJ,6CAAkDF,aAAlD,EAAN;AATJ;AAWD;AAED;;;;;;;;;;;;;;;AAcA,OAAO,SAASC,mBAAT,CAA6BH,MAA7B,EAAqC;AAC1C,MAAMK,cAAc,GAAGN,oBAAoB,CAACC,MAAD,CAA3C;;AACA,MAAIK,cAAJ,EAAoB;AAClB,WAAOA,cAAP;AAHwC,IAK1C;;;AACA,MAAMC,KAAK,GAAGN,MAAM,CAACO,KAAPP,CAAa,GAAbA,CAAd;;AACA,SAAOA,MAAM,CAACQ,MAAPR,GAAgB,CAAvB,EAA0B;AACxBM,SAAK,CAACG,GAANH;AACAN,UAAM,GAAGM,KAAK,CAACI,IAANJ,CAAW,GAAXA,CAATN;;AACA,QAAMK,eAAc,GAAGN,oBAAoB,CAACC,MAAD,CAA3C;;AACA,QAAIK,eAAJ,EAAoB;AAClB,aAAOA,eAAP;AACD;AACF;AACF","names":["resolveLocale","resolveLocaleForData","locale","options","localeMatcher","resolveLocaleLookup","RangeError","resolvedLocale","parts","split","length","pop","join"],"sources":["E:\\courses\\my_personal_file\\challenges\\comments-section\\client\\node_modules\\relative-time-format\\source\\resolveLocale.js"],"sourcesContent":["import {\r\n  resolveLocale as resolveLocaleForData\r\n} from './LocaleDataStore'\r\n\r\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * @param  {string} locale\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocale(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocale(\"xx-Latn\")\r\n */\r\nexport default function resolveLocale(locale, options = {}) {\r\n  const localeMatcher = options.localeMatcher || 'lookup'\r\n  switch (localeMatcher) {\r\n    case 'lookup':\r\n      return resolveLocaleLookup(locale)\r\n    // \"best fit\" locale matching is not supported.\r\n    // https://github.com/catamphetamine/relative-time-format/issues/2\r\n    case 'best fit':\r\n      // return resolveLocaleBestFit(locale)\r\n      return resolveLocaleLookup(locale)\r\n    default:\r\n      throw new RangeError(`Invalid \"localeMatcher\" option: ${localeMatcher}`)\r\n  }\r\n}\r\n\r\n/**\r\n * Resolves a locale to a supported one (if any).\r\n * Starts from the most specific locale and gradually\r\n * falls back to less specific ones.\r\n * This is a basic implementation of the \"lookup\" algorithm.\r\n * https://tools.ietf.org/html/rfc4647#section-3.4\r\n * @param  {string} locale\r\n * @return {string} [locale]\r\n * @example\r\n * // Returns \"sr\"\r\n * resolveLocaleLookup(\"sr-Cyrl-BA\")\r\n * // Returns `undefined`\r\n * resolveLocaleLookup(\"xx-Latn\")\r\n */\r\nexport function resolveLocaleLookup(locale) {\r\n  const resolvedLocale = resolveLocaleForData(locale)\r\n  if (resolvedLocale) {\r\n    return resolvedLocale\r\n  }\r\n  // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\r\n  const parts = locale.split('-')\r\n  while (locale.length > 1) {\r\n    parts.pop()\r\n    locale = parts.join('-')\r\n    const resolvedLocale = resolveLocaleForData(locale)\r\n    if (resolvedLocale) {\r\n      return resolvedLocale\r\n    }\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}